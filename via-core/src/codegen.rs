use std::{collections::HashMap, fmt::Write, path::PathBuf};

use anyhow::Result;
use convert_case::{Case, Casing};

use crate::ast::{Controller, ControllerActions, Field, Model, ParamEntry, ParamsKind, Resource};

pub const GENERATED_HEADER: &str = "// @generated by via-core. DO NOT EDIT BY HAND.\n";

#[derive(Debug, Clone)]
pub struct GeneratedFile {
    pub relative_path: PathBuf,
    pub contents: String,
}

#[derive(Debug, Default)]
pub struct GenerationOutput {
    pub files: Vec<GeneratedFile>,
}

impl GenerationOutput {
    pub fn push<S: Into<String>, P: Into<PathBuf>>(&mut self, path: P, contents: S) {
        self.files.push(GeneratedFile {
            relative_path: path.into(),
            contents: contents.into(),
        });
    }
}

pub fn generate(resources: &[Resource]) -> Result<GenerationOutput> {
    let mut output = GenerationOutput::default();
    let mut ts_modules: Vec<String> = Vec::new();

    for resource in resources {
        let module_name = resource.name.to_case(Case::Snake);
        let controller = resource
            .controller
            .clone()
            .unwrap_or_else(default_controller);
        let param_structs =
            build_param_structs(&resource.name, &controller, resource.model.as_ref());

        if let Some(model) = &resource.model {
            let path = PathBuf::from(format!("src/models/{}.rs", module_name));
            let contents = render_model(resource, model, &param_structs);
            output.push(path, contents);

            let ts_path = PathBuf::from(format!("ts/models/{}.ts", module_name));
            let ts_contents = render_ts_models(resource, model, &param_structs);
            output.push(ts_path, ts_contents);
            ts_modules.push(module_name.clone());
        }

        let path = PathBuf::from(format!("src/controllers/{}.rs", module_name));
        let contents = render_controller(
            resource,
            &controller,
            resource.model.as_ref(),
            &param_structs,
        );
        output.push(path, contents);
    }

    if !resources.is_empty() {
        output.push(
            PathBuf::from("src/models/mod.rs"),
            render_models_mod(resources),
        );
        output.push(
            PathBuf::from("src/controllers/mod.rs"),
            render_controllers_mod(resources),
        );
        output.push(PathBuf::from("src/lib.rs"), render_root_lib());
        output.push(PathBuf::from("Cargo.toml"), render_manifest());
    }

    if !ts_modules.is_empty() {
        output.push(PathBuf::from("ts/index.ts"), render_ts_index(&ts_modules));
    }

    Ok(output)
}

fn default_controller() -> Controller {
    Controller {
        params: Vec::new(),
        respond_with: vec!["html".into(), "json".into()],
        actions: ControllerActions::AutoCrud,
    }
}

fn render_model(resource: &Resource, model: &Model, param_structs: &[ParamStruct]) -> String {
    let mut buffer = String::new();
    writeln!(
        buffer,
        "{}// source: {}",
        GENERATED_HEADER, resource.file_path
    )
    .unwrap();
    buffer.push('\n');
    buffer.push_str("use serde::{Deserialize, Serialize};\n\n");

    let struct_name = &resource.name;
    writeln!(buffer, "#[derive(Debug, Clone, Serialize, Deserialize)]").unwrap();
    writeln!(buffer, "pub struct {} {{", struct_name).unwrap();

    for field in &model.fields {
        for line in field_doc_lines(field) {
            writeln!(buffer, "    /// {}", line).unwrap();
        }
        if field.optional {
            buffer.push_str("    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n");
        }
        if field.attributes.serialize == Some(false) {
            buffer.push_str("    #[serde(skip_serializing, skip_deserializing)]\n");
        }
        let (ty, _comment) = render_field_type(field, field.optional);
        writeln!(buffer, "    pub {}: {},", field.name, ty).unwrap();
    }
    buffer.push_str("}\n");

    if !param_structs.is_empty() {
        buffer.push('\n');
    }

    for param_struct in param_structs {
        writeln!(
            buffer,
            "#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {} {{",
            param_struct.name
        )
        .unwrap();
        for field in &param_struct.fields {
            for line in &field.doc {
                writeln!(buffer, "    /// {}", line).unwrap();
            }
            if field.optional {
                buffer
                    .push_str("    #[serde(skip_serializing_if = \"Option::is_none\", default)]\n");
            }
            writeln!(buffer, "    pub {}: {},", field.name, field.ty).unwrap();
        }
        buffer.push_str("}\n\n");
    }

    buffer.trim_end().to_owned() + "\n"
}

fn render_controller(
    resource: &Resource,
    controller: &Controller,
    model: Option<&Model>,
    param_structs: &[ParamStruct],
) -> String {
    let mut buffer = String::new();
    writeln!(
        buffer,
        "{}// source: {}",
        GENERATED_HEADER, resource.file_path
    )
    .unwrap();
    buffer.push('\n');
    buffer.push_str("use loco_rs::prelude::*;\n");
    buffer.push_str("use serde_json::json;\n");

    if !param_structs.is_empty() {
        let mut names: Vec<String> = param_structs.iter().map(|ps| ps.name.clone()).collect();
        names.sort();
        names.dedup();
        writeln!(buffer, "use crate::models::{{{}}};", names.join(", ")).unwrap();
    }

    buffer.push('\n');

    if !controller.respond_with.is_empty() {
        let formats = controller
            .respond_with
            .iter()
            .map(|f| format!("\"{}\"", f))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(
            buffer,
            "pub const RESPOND_WITH: &[&str] = &[{}];\n",
            formats
        )
        .unwrap();
    } else {
        buffer.push_str("pub const RESPOND_WITH: &[&str] = &[\"html\", \"json\"];\n\n");
    }

    let routes_fn = render_routes_fn(&resource.name, controller);
    buffer.push_str(&routes_fn);
    buffer.push('\n');

    let actions = resolve_actions(controller);
    for action in actions {
        buffer.push_str(&render_action_stub(resource, &action, &param_structs));
    }

    if let Some(model) = model {
        buffer.push_str("// Associated model fields\n");
        for field in &model.fields {
            let (ty, comment) = render_field_type(field, field.optional);
            if let Some(comment) = comment {
                writeln!(buffer, "// - {}: {} ({})", field.name, ty, comment).unwrap();
            } else {
                writeln!(buffer, "// - {}: {}", field.name, ty).unwrap();
            }
        }
    }

    buffer.trim_end().to_owned() + "\n"
}

struct ActionSpec {
    pub action_name: String,
    pub handler_name: String,
    pub method: &'static str,
    pub path: &'static str,
}

fn resolve_actions(controller: &Controller) -> Vec<ActionSpec> {
    match &controller.actions {
        ControllerActions::Manual(custom) if !custom.is_empty() => custom
            .iter()
            .map(|action| ActionSpec {
                action_name: action.name.clone(),
                handler_name: action.name.to_case(Case::Snake),
                method: "get",
                path: "/",
            })
            .collect(),
        _ => vec![
            ActionSpec {
                action_name: "index".into(),
                handler_name: "index".into(),
                method: "get",
                path: "/",
            },
            ActionSpec {
                action_name: "show".into(),
                handler_name: "show".into(),
                method: "get",
                path: "/{id}",
            },
            ActionSpec {
                action_name: "create".into(),
                handler_name: "create".into(),
                method: "post",
                path: "/",
            },
            ActionSpec {
                action_name: "update".into(),
                handler_name: "update".into(),
                method: "put",
                path: "/{id}",
            },
            ActionSpec {
                action_name: "destroy".into(),
                handler_name: "destroy".into(),
                method: "delete",
                path: "/{id}",
            },
        ],
    }
}

fn render_routes_fn(resource_name: &str, controller: &Controller) -> String {
    let mut buffer = String::new();
    let plural = pluralize(resource_name);
    let prefix = format!("{}/", plural.to_case(Case::Snake));

    buffer.push_str("pub fn routes() -> Routes {\n");
    buffer.push_str("    Routes::new()\n");
    buffer.push_str(&format!("        .prefix(\"{}\")\n", prefix));

    for action in resolve_actions(controller) {
        buffer.push_str(&format!(
            "        .add(\"{}\", {}({}))\n",
            action.path, action.method, action.handler_name
        ));
    }

    buffer.push_str("}\n");
    buffer
}

fn render_field_type(field: &Field, optional: bool) -> (String, Option<String>) {
    let (base, comment) = map_builtin(&field.ty.name);
    let ty = if optional {
        format!("Option<{}>", base)
    } else {
        base.clone()
    };
    (ty, comment)
}

fn field_doc_lines(field: &Field) -> Vec<String> {
    let mut docs = Vec::new();
    if let Some(false) = field.attributes.serialize {
        docs.push("Not serialized in API responses".into());
    }
    docs
}

#[derive(Debug)]
struct ParamStruct {
    name: String,
    fields: Vec<ParamField>,
}

#[derive(Debug)]
struct ParamField {
    name: String,
    ty: String,
    optional: bool,
    doc: Vec<String>,
}

fn build_param_structs(
    resource_struct_name: &str,
    controller: &Controller,
    model: Option<&Model>,
) -> Vec<ParamStruct> {
    let mut structs = Vec::new();
    if controller.params.is_empty() {
        return structs;
    }

    let field_map = model.map(|m| build_field_index(m));

    for profile in &controller.params {
        match &profile.name {
            ParamsKind::Editable => {
                let create_name = format!("{}CreateParams", resource_struct_name);
                let update_name = format!("{}UpdateParams", resource_struct_name);
                let create_fields =
                    build_param_fields(&profile.entries, &field_map, ParamUsage::Create);
                let update_fields =
                    build_param_fields(&profile.entries, &field_map, ParamUsage::Update);
                structs.push(ParamStruct {
                    name: create_name,
                    fields: create_fields,
                });
                structs.push(ParamStruct {
                    name: update_name,
                    fields: update_fields,
                });
            }
            ParamsKind::Named(name) => {
                let struct_name = format!(
                    "{}{}Params",
                    resource_struct_name,
                    name.to_case(Case::Pascal)
                );
                let fields = build_param_fields(&profile.entries, &field_map, ParamUsage::Create);
                structs.push(ParamStruct {
                    name: struct_name,
                    fields,
                });
            }
        }
    }

    structs
}

#[derive(Clone, Copy)]
enum ParamUsage {
    Create,
    Update,
}

fn build_param_fields(
    entries: &[ParamEntry],
    field_map: &Option<HashMap<String, &Field>>,
    usage: ParamUsage,
) -> Vec<ParamField> {
    entries
        .iter()
        .map(|entry| {
            let (ty, comment, derived_optional) = match field_map {
                Some(map) => map
                    .get(&entry.name)
                    .map(|field| {
                        let optional = match usage {
                            ParamUsage::Create => entry.optional || field.optional,
                            ParamUsage::Update => true,
                        };
                        let (ty, comment) = render_param_type(field, optional);
                        (ty, comment, optional)
                    })
                    .unwrap_or_else(|| fallback_param_type(&entry.name, entry.optional, usage)),
                None => fallback_param_type(&entry.name, entry.optional, usage),
            };

            let mut doc = Vec::new();
            if let Some(comment) = comment {
                doc.push(comment);
            }
            ParamField {
                name: entry.name.clone(),
                ty,
                optional: derived_optional,
                doc,
            }
        })
        .collect()
}

fn render_param_type(field: &Field, optional: bool) -> (String, Option<String>) {
    let (base, comment) = map_builtin(&field.ty.name);
    let ty = if optional {
        format!("Option<{}>", base)
    } else {
        base.clone()
    };
    (ty, comment)
}

fn fallback_param_type(
    name: &str,
    entry_optional: bool,
    usage: ParamUsage,
) -> (String, Option<String>, bool) {
    let optional = match usage {
        ParamUsage::Create => entry_optional,
        ParamUsage::Update => true,
    };
    let ty = if optional {
        "Option<String>".to_string()
    } else {
        "String".to_string()
    };
    let comment = Some(format!(
        "TODO: confirm type for `{}` (fallback to String)",
        name
    ));
    (ty, comment, optional)
}

fn build_field_index(model: &Model) -> HashMap<String, &Field> {
    let mut map = HashMap::new();
    for field in &model.fields {
        map.insert(field.name.clone(), field);
    }
    map
}

fn map_builtin(name: &str) -> (String, Option<String>) {
    match name {
        "String" | "Text" => ("String".into(), None),
        "Boolean" => ("bool".into(), None),
        "Integer" => ("i64".into(), None),
        "BigInt" => ("i128".into(), None),
        "Float" => ("f64".into(), None),
        "Decimal" => (
            "f64".into(),
            Some("Consider rust_decimal::Decimal for exact precision".into()),
        ),
        "DateTime" => (
            "String".into(),
            Some("ISO 8601 DateTime string; swap for chrono if desired".into()),
        ),
        "Date" => ("String".into(), Some("ISO 8601 Date string".into())),
        "Time" => ("String".into(), Some("ISO 8601 Time string".into())),
        "UUID" => (
            "String".into(),
            Some("UUID string; use uuid::Uuid for strong typing".into()),
        ),
        "Json" => ("serde_json::Value".into(), None),
        other => (
            other.to_owned(),
            Some(format!("TODO: map Via type `{}` to a Rust type", other)),
        ),
    }
}

fn pluralize(word: &str) -> String {
    let lower = word.to_case(Case::Snake);
    if lower.ends_with('s')
        || lower.ends_with('x')
        || lower.ends_with("sh")
        || lower.ends_with("ch")
        || lower.ends_with('z')
    {
        format!("{}es", lower)
    } else if lower.ends_with('y')
        && !matches!(
            lower.chars().nth(lower.len().saturating_sub(2)),
            Some('a' | 'e' | 'i' | 'o' | 'u')
        )
    {
        format!("{}ies", &lower[..lower.len() - 1])
    } else {
        format!("{}s", lower)
    }
}

fn render_models_mod(resources: &[Resource]) -> String {
    let mut buffer = String::new();
    buffer.push_str(GENERATED_HEADER);
    buffer.push('\n');
    for resource in resources {
        let module = resource.name.to_case(Case::Snake);
        writeln!(buffer, "pub mod {};", module).unwrap();
    }
    buffer.push('\n');
    for resource in resources {
        let module = resource.name.to_case(Case::Snake);
        writeln!(buffer, "pub use {}::*;", module).unwrap();
    }
    buffer
}

fn render_controllers_mod(resources: &[Resource]) -> String {
    let mut buffer = String::new();
    buffer.push_str(GENERATED_HEADER);
    buffer.push('\n');
    for resource in resources {
        let module = resource.name.to_case(Case::Snake);
        writeln!(buffer, "pub mod {};", module).unwrap();
    }
    buffer.push('\n');
    for resource in resources {
        let module = resource.name.to_case(Case::Snake);
        writeln!(buffer, "pub use {}::*;", module).unwrap();
    }
    buffer
}

fn render_root_lib() -> String {
    let mut buffer = String::new();
    buffer.push_str(GENERATED_HEADER);
    buffer.push_str("\npub mod controllers;\npub mod models;\n");
    buffer
}

fn render_manifest() -> String {
    let mut buffer = String::new();
    buffer.push_str("# @generated by via-core. DO NOT EDIT BY HAND.\n");
    buffer.push_str("\n[package]\n");
    buffer.push_str("name = \"via-generated\"\n");
    buffer.push_str("version = \"0.1.0\"\n");
    buffer.push_str("edition = \"2021\"\n");
    buffer.push_str("publish = false\n\n");
    buffer.push_str("[lib]\n");
    buffer.push_str("path = \"src/lib.rs\"\n\n");
    buffer.push_str("[dependencies]\n");
    buffer.push_str("loco-rs = { version = \"0.16\" }\n");
    buffer.push_str("serde = { version = \"1\", features = [\"derive\"] }\n");
    buffer.push_str("serde_json = { version = \"1\" }\n");
    buffer
}

fn render_action_stub(
    resource: &Resource,
    action: &ActionSpec,
    param_structs: &[ParamStruct],
) -> String {
    let mut buffer = String::new();
    let message = format!("{}#{}", resource.name, action.action_name);
    match action.action_name.as_str() {
        "index" => {
            writeln!(
                buffer,
                "pub async fn {}(State(_ctx): State<AppContext>) -> Result<Response> {{",
                action.handler_name
            )
            .unwrap();
            writeln!(
                buffer,
                "    format::json(json!({{\"todo\": \"{}\"}}))",
                message
            )
            .unwrap();
            buffer.push_str("}\n\n");
        }
        "show" | "destroy" => {
            writeln!(
                buffer,
                "pub async fn {}(State(_ctx): State<AppContext>, Path(id): Path<String>) -> Result<Response> {{",
                action.handler_name
            )
            .unwrap();
            writeln!(
                buffer,
                "    format::json(json!({{\"todo\": \"{}\", \"id\": id}}))",
                message
            )
            .unwrap();
            buffer.push_str("}\n\n");
        }
        "create" => {
            let struct_name =
                find_param_struct_name(param_structs, &format!("{}CreateParams", resource.name))
                    .unwrap_or_else(|| "serde_json::Value".to_owned());
            writeln!(
                buffer,
                "pub async fn {}(State(_ctx): State<AppContext>, Json(payload): Json<{}>) -> Result<Response> {{",
                action.handler_name,
                struct_name
            )
            .unwrap();
            writeln!(
                buffer,
                "    format::json(json!({{\"todo\": \"{}\", \"payload\": payload}}))",
                message
            )
            .unwrap();
            buffer.push_str("}\n\n");
        }
        "update" => {
            let struct_name =
                find_param_struct_name(param_structs, &format!("{}UpdateParams", resource.name))
                    .unwrap_or_else(|| "serde_json::Value".to_owned());
            writeln!(
                buffer,
                "pub async fn {}(State(_ctx): State<AppContext>, Path(id): Path<String>, Json(payload): Json<{}>) -> Result<Response> {{",
                action.handler_name,
                struct_name
            )
            .unwrap();
            writeln!(
                buffer,
                "    format::json(json!({{\"todo\": \"{}\", \"id\": id, \"payload\": payload}}))",
                message
            )
            .unwrap();
            buffer.push_str("}\n\n");
        }
        _ => {
            writeln!(
                buffer,
                "pub async fn {}(State(_ctx): State<AppContext>) -> Result<Response> {{",
                action.handler_name
            )
            .unwrap();
            writeln!(
                buffer,
                "    format::json(json!({{\"todo\": \"{}\"}}))",
                message
            )
            .unwrap();
            buffer.push_str("}\n\n");
        }
    }
    buffer
}

fn find_param_struct_name(param_structs: &[ParamStruct], target: &str) -> Option<String> {
    param_structs
        .iter()
        .find(|ps| ps.name == target)
        .map(|ps| ps.name.clone())
}

fn render_ts_models(resource: &Resource, model: &Model, param_structs: &[ParamStruct]) -> String {
    let mut buffer = String::new();
    writeln!(buffer, "// @generated by via-core. DO NOT EDIT BY HAND.").unwrap();
    buffer.push('\n');

    let interface_name = &resource.name;
    writeln!(buffer, "export interface {} {{", interface_name).unwrap();
    for field in &model.fields {
        if field.attributes.serialize == Some(false) {
            continue;
        }
        for comment in field_doc_lines(field) {
            writeln!(buffer, "  // {}", comment).unwrap();
        }
        let (ts_type, note) = map_via_type_to_ts(&field.ty.name);
        if let Some(note) = note {
            writeln!(buffer, "  // {}", note).unwrap();
        }
        let optional = if field.optional { "?" } else { "" };
        writeln!(buffer, "  {}{}: {};", field.name, optional, ts_type).unwrap();
    }
    buffer.push_str("}\n\n");

    for param_struct in param_structs {
        writeln!(buffer, "export type {} = {{", param_struct.name).unwrap();
        for field in &param_struct.fields {
            for doc in &field.doc {
                writeln!(buffer, "  // {}", doc).unwrap();
            }
            let ts_type = map_rust_type_to_ts(&field.ty);
            let optional = if field.optional { "?" } else { "" };
            writeln!(buffer, "  {}{}: {};", field.name, optional, ts_type).unwrap();
        }
        buffer.push_str("};\n\n");
    }

    buffer.trim_end().to_owned() + "\n"
}

fn render_ts_index(modules: &[String]) -> String {
    let mut buffer = String::new();
    buffer.push_str("// @generated by via-core. DO NOT EDIT BY HAND.\n\n");
    for module in modules {
        writeln!(buffer, "export * from './models/{}';", module).unwrap();
    }
    buffer
}

fn map_via_type_to_ts(name: &str) -> (String, Option<String>) {
    match name {
        "String" | "Text" => ("string".into(), None),
        "Boolean" => ("boolean".into(), None),
        "Integer" | "BigInt" | "Float" | "Decimal" => ("number".into(), None),
        "DateTime" | "Date" | "Time" => ("string".into(), Some("ISO 8601 formatted string".into())),
        "UUID" => ("string".into(), Some("UUID string".into())),
        "Json" => ("unknown".into(), None),
        other => (
            "unknown".into(),
            Some(format!("TODO: map Via type `{}` to a TS type", other)),
        ),
    }
}

fn map_rust_type_to_ts(ty: &str) -> String {
    let trimmed = ty.trim();
    if let Some(inner) = trimmed
        .strip_prefix("Option<")
        .and_then(|v| v.strip_suffix('>'))
    {
        return map_rust_type_to_ts(inner);
    }
    if let Some(inner) = trimmed
        .strip_prefix("Vec<")
        .and_then(|v| v.strip_suffix('>'))
    {
        let inner_ts = map_rust_type_to_ts(inner);
        return format!("{}[]", inner_ts);
    }
    match trimmed {
        "String" | "&str" => "string".into(),
        "bool" | "Boolean" => "boolean".into(),
        "i64" | "i32" | "i16" | "i8" | "i128" | "u64" | "u32" | "u16" | "u8" | "f64" | "f32" => {
            "number".into()
        }
        "serde_json::Value" => "unknown".into(),
        other => format!("unknown /* {} */", other),
    }
}
